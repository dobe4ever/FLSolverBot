This Telegram bot automatically redeploys to Render.com whenever new code is pushed to the GitHub repo.

Development and testing are done in GitHub Codespaces using the same repo and secrets (except for the Telegram bot token). This allows live testing directly from the browser IDE while interacting with a separate Telegram bot instance in the app.

To run locally:
`node src/index.js`

# Overview

The bot is a Fantasyland Poker solver that supports all variants (14‚Äì17 cards). It processes screenshots from any poker app where the hero is in Fantasyland mode. The image is analyzed using a vision-language model to identify visible cards, which are then passed to the solver for optimal hand arrangement.

**Flow:**
Screenshot ‚Üí Telegram API (image) ‚Üí Base64 ‚Üí Vision model (cards ‚Üí text) ‚Üí Solver ‚Üí Formatted solution ‚Üí Telegram API (send reply)

# Files

```
FLSOLVERBOT
‚îú‚îÄ‚îÄ node_modules
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gemini.service.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mistral.service.js
‚îÇ   ‚îú‚îÄ‚îÄ solver
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ solver.js
‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ TODO.md
```
# Codebase

===== FILE: src/services/mistral.service.js =====

```
// src/services/mistral.service.js

const { Mistral } = require("@mistralai/mistralai");

// Initialize the Mistral client
const client = new Mistral({
    apiKey: process.env.MISTRAL_API_KEY,
});

const temperature = 0;
const systemInstruction = `You are analyzing a screenshot of a poker app showing several playing cards face up in a row. Your job is to identify them and output them in standard poker notation.

STEP 1 - CAREFULLY IDENTIFY EACH CARD:
From the row of visible playing cards, starting from the first card on the left, list each card writing out the rank and suit in words.
Format:
1. [rank], [suit]
2. [rank], [suit]
etc.

STEP 2 - CONVERT TO STANDARD NOTATION:
Use this exact notation system:
- RANKS: 2 3 4 5 6 7 8 9 T J Q K A
- SUITS: C = Clubs, D = Diamonds, H = Hearts, S = Spades

CRITICAL: 
- Ten is ALWAYS written as 'T', NEVER as '10'
- Each card is exactly 2 characters: rank + suit
- Example: TC = Ten of Clubs, 9H = Nine of Hearts, AS = Ace of Spades

STEP 3 - OUTPUT:
Provide all cards in a single line, separated by single spaces, enclosed in triple backticks.
- Example:
\`\`\`9C TD 6S QH\`\`\`
`;

// Model configurations - easy to add new models here
const MODEL_CONFIGS = {
    'mistral-large': {
        name: 'mistral-large-latest',
        displayName: 'Mistral Large',
    },
    'mistral-small': {
        name: 'mistral-small-latest',
        displayName: 'mistral Small',
    },
};

// Default model
let currentModelKey = 'mistral-small';

/**
 * Sets the current model to use
 * @param {string} modelKey - Key from MODEL_CONFIGS
 * @returns {boolean} - True if model was set successfully
 */
function setModel(modelKey) {
    if (MODEL_CONFIGS[modelKey]) {
        currentModelKey = modelKey;
        return true;
    }
    return false;
}

/**
 * Gets the current model configuration
 * @returns {object} - Current model config
 */
function getCurrentModel() {
    return MODEL_CONFIGS[currentModelKey];
}

/**
 * Gets all available models
 * @returns {object} - All model configurations
 */
function getAvailableModels() {
    return MODEL_CONFIGS;
}

/**
 * Identifies cards from an image buffer using Mistral Vision.
 * @param {Buffer} imageBuffer The image data as a buffer.
 * @returns {Promise<string|null>} A string of card codes, or null if parsing fails.
 */
async function identifyCardsFromImage(imageBuffer) {
    try {
        const modelConfig = MODEL_CONFIGS[currentModelKey];
        
        // Convert buffer to base64
        const base64Image = imageBuffer.toString('base64');
        const base64DataUrl = `data:image/jpeg;base64,${base64Image}`;

        const chatResponse = await client.chat.complete({
            model: modelConfig.name,
            temperature: temperature,
            messages: [
                {
                    role: "system",
                    content: systemInstruction,
                },
                {
                    role: "user",
                    content: [
                        {
                            type: "image_url",
                            imageUrl: base64DataUrl,
                        },
                    ],
                },
            ],
        });

        const responseText = chatResponse.choices[0].message.content;

        // Extract the content from between the triple backticks
        const match = responseText.match(/\`\`\`([\s\S]*?)\`\`\`/);

        if (match && match[1]) {
            // Return the cleaned, trimmed string of cards
            return match[1].trim();
        } else {
            console.error("Mistral response did not contain the expected format:", responseText);
            return null;
        }

    } catch (error) {
        console.error("Error calling Mistral API:", error);
        throw new Error("Failed to get a valid response from the vision model.");
    }
}

module.exports = { 
    identifyCardsFromImage, 
    setModel, 
    getCurrentModel, 
    getAvailableModels 
};

```

===== FILE: src/services/gemini.service.js =====

```
// src/services/gemini.service.js

const { GoogleGenAI } = require("@google/genai");

// Initialize the Gemini client
const ai = new GoogleGenAI({
    apiKey: process.env.GEMINI_API_KEY,
});

const temperature = 0;
const systemInstruction = `You are analyzing a screenshot of a poker app showing several playing cards face up in a row. Your job is to identify them and output them in standard poker notation.

STEP 1 - CAREFULLY IDENTIFY EACH CARD:
From the row of visible playing cards, starting from the first card on the left, list each card writing out the rank and suit in words.
Format:
1. [rank], [suit]
2. [rank], [suit]
etc.

STEP 2 - CONVERT TO STANDARD NOTATION:
Use this exact notation system:
- RANKS: 2 3 4 5 6 7 8 9 T J Q K A
- SUITS: C = Clubs, D = Diamonds, H = Hearts, S = Spades

CRITICAL: 
- Ten is ALWAYS written as 'T', NEVER as '10'
- Each card is exactly 2 characters: rank + suit
- Example: TC = Ten of Clubs, 9H = Nine of Hearts, AS = Ace of Spades

STEP 3 - OUTPUT:
Provide all cards in a single line, separated by single spaces, enclosed in triple backticks.
- Example:
\`\`\`9C TD 6S QH\`\`\`
`;

// Model configurations - easy to add new models here
const MODEL_CONFIGS = {
    'pro': {
        provider: 'gemini', 
        name: 'gemini-2.5-pro',
        displayName: 'Gemini 2.5 Pro',
        thinkingBudget: -1,
    },
        'flash': {
        provider: 'gemini',  
        name: 'gemini-flash-latest',
        displayName: 'Gemini Flash',
        thinkingBudget: -1,
    },
    // ... any other gemini models
};

// Default model
let currentModelKey = 'pro';

/**
 * Sets the current model to use
 * @param {string} modelKey - Key from MODEL_CONFIGS
 * @returns {boolean} - True if model was set successfully
 */
function setModel(modelKey) {
    if (MODEL_CONFIGS[modelKey]) {
        currentModelKey = modelKey;
        return true;
    }
    return false;
}

/**
 * Gets the current model configuration
 * @returns {object} - Current model config
 */
function getCurrentModel() {
    return MODEL_CONFIGS[currentModelKey];
}

/**
 * Gets all available models
 * @returns {object} - All model configurations
 */
function getAvailableModels() {
    return MODEL_CONFIGS;
}

/**
 * Identifies cards from an image buffer using Gemini Vision.
 * @param {Buffer} imageBuffer The image data as a buffer.
 * @returns {Promise<string|null>} A string of card codes, or null if parsing fails.
 */
async function identifyCardsFromImage(imageBuffer) {
    try {
        const modelConfig = MODEL_CONFIGS[currentModelKey];
        
        const config = {
            temperature: temperature,
            thinkingConfig: {
                thinkingBudget: modelConfig.thinkingBudget,
            },
            systemInstruction: [
                {
                    text: systemInstruction,
                }
            ],
        };

        const contents = [
            {
                role: 'user',
                parts: [
                    {
                        inlineData: {
                            mimeType: 'image/jpeg',
                            data: imageBuffer.toString("base64"),
                        },
                    },
                ],
            },
        ];

        const response = await ai.models.generateContent({
            model: modelConfig.name,
            config,
            contents,
        });

        const responseText = response.text;

        // Extract the content from between the triple backticks
        const match = responseText.match(/\`\`\`([\s\S]*?)\`\`\`/);

        if (match && match[1]) {
            // Return the cleaned, trimmed string of cards
            return match[1].trim();
        } else {
            console.error("Gemini response did not contain the expected format:", responseText);
            return null;
        }

    } catch (error) {
        console.error("Error calling Gemini API:", error);
        throw new Error("Failed to get a valid response from the vision model.");
    }
}

module.exports = { 
    identifyCardsFromImage, 
    setModel, 
    getCurrentModel, 
    getAvailableModels 
};
```

===== FILE: src/solver/solver.js =====

```
// src/solver/solver.js

const RANKS = ["2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"];
const SUITS = ["‚ô†Ô∏è", "‚ù§Ô∏è", "üî∑", "üü¢"];
const SUIT_MAP = { "‚ô†Ô∏è": 0, "‚ù§Ô∏è": 1, "üî∑": 2, "üü¢": 3, S: 0, H: 1, D: 2, C: 3 };

function parseCard(code) {
  if (!code || code.length < 2) return null;
  const c = code.trim().toUpperCase();
  const r = c[0];
  const sRaw = c.slice(1);
  const rank = RANKS.indexOf(r);
  const suit = SUIT_MAP[sRaw];
  if (rank === -1 || suit === undefined) return null;
  return { rank, suit, str: r + SUITS[suit] };
}

function evalHand(hand) {
  const len = hand.length;
  const ranks = new Array(13).fill(0);
  const suits = new Array(4).fill(0);
  let handRanks = [];
  for (let i = 0; i < len; i++) {
    ranks[hand[i].rank]++;
    suits[hand[i].suit]++;
    handRanks.push(hand[i].rank);
  }
  handRanks.sort((a, b) => b - a);
  const isFlush = suits.some((count) => count >= 5);
  const groups = [];
  for (let i = 12; i >= 0; i--) {
    if (ranks[i] > 0) groups.push([i, ranks[i]]);
  }
  groups.sort((a, b) => b[1] - a[1]);
  let straightHigh = -1;
  const uniqueRanks = [...new Set(handRanks)].sort((a, b) => a - b);
  if (uniqueRanks.length >= 5) {
    if (uniqueRanks.includes(12) && uniqueRanks.includes(0) && uniqueRanks.includes(1) && uniqueRanks.includes(2) && uniqueRanks.includes(3)) {
      straightHigh = 3;
    } else {
      for (let i = uniqueRanks.length - 1; i >= 4; i--) {
        if (uniqueRanks[i] - uniqueRanks[i - 4] === 4) {
          straightHigh = uniqueRanks[i];
          break;
        }
      }
    }
  }
  if (len === 5) {
    if (straightHigh !== -1 && isFlush) return { cat: 8, kickers: [straightHigh] };
    if (groups[0][1] === 4) return { cat: 7, kickers: [groups[0][0], groups[1]?.[0]] };
    if (groups[0][1] === 3 && groups[1][1] === 2) return { cat: 6, kickers: [groups[0][0], groups[1][0]] };
    if (isFlush) return { cat: 5, kickers: handRanks };
    if (straightHigh !== -1) return { cat: 4, kickers: [straightHigh] };
    if (groups[0][1] === 3) return { cat: 3, kickers: [groups[0][0], ...handRanks.filter((r) => r !== groups[0][0])] };
    if (groups[0][1] === 2 && groups[1][1] === 2) return { cat: 2, kickers: [groups[0][0], groups[1][0], groups[2]?.[0]] };
    if (groups[0][1] === 2) return { cat: 1, kickers: [groups[0][0], ...handRanks.filter((r) => r !== groups[0][0])] };
    return { cat: 0, kickers: handRanks };
  } else {
    if (groups[0][1] === 3) return { cat: 3, kickers: [groups[0][0]] };
    if (groups[0][1] === 2) return { cat: 1, kickers: [groups[0][0], groups[1]?.[0]] };
    return { cat: 0, kickers: handRanks };
  }
}

function compareHands(evalA, evalB) {
  if (evalA.cat !== evalB.cat) return evalA.cat - evalB.cat;
  for (let i = 0; i < evalA.kickers.length; i++) {
    if (evalA.kickers[i] !== evalB.kickers[i]) {
      return evalA.kickers[i] - evalB.kickers[i];
    }
  }
  return 0;
}

const defaultRoyalties = {
  back: { 4: 2, 5: 4, 6: 6, 7: 10, 8: 15 },
  middle: { 3: 2, 4: 4, 5: 8, 6: 12, 7: 20, 8: 30 },
  frontPairs: { 4: 1, 5: 2, 6: 3, 7: 4, 8: 5, 9: 6, 10: 7, 11: 8, 12: 9 },
  frontTripsBase: 10,
};

function getRoyalties(ev, tier) {
  if (tier === "back") return defaultRoyalties.back[ev.cat] || 0;
  if (tier === "middle") return defaultRoyalties.middle[ev.cat] || 0;
  if (tier === "front") {
    if (ev.cat === 3) return defaultRoyalties.frontTripsBase + ev.kickers[0];
    if (ev.cat === 1) return defaultRoyalties.frontPairs[ev.kickers[0]] || 0;
  }
  return 0;
}

function* combinations(n, k) {
  if (k > n || k < 0) return;
  const indices = Array.from({ length: k }, (_, i) => i);
  while (true) {
    yield indices;
    let i = k - 1;
    while (i >= 0 && indices[i] === i + n - k) i--;
    if (i < 0) return;
    indices[i]++;
    for (let j = i + 1; j < k; j++) indices[j] = indices[j - 1] + 1;
  }
}

function isRepeatFantasyland(backEv, middleEv, frontEv) {
  if (backEv.cat >= 7) return true;
  if (middleEv.cat >= 6) return true;
  if (frontEv.cat === 3) return true;
  return false;
}

function areDisjoint(indicesA, indicesB) {
  const setA = new Set(indicesA);
  for (const index of indicesB) {
    if (setA.has(index)) return false;
  }
  return true;
}

function solveOptimizedV2(parsedCards) {
  console.log('üîç [SOLVER] Starting solver with', parsedCards.length, 'cards');
  const solverStartTime = Date.now();
  
  const numCards = parsedCards.length;
  if (numCards < 13) throw new Error("Solver requires at least 13 cards.");
  
  let bestOverallArrangement = null;
  let bestRepeatArrangement = null;
  
  console.log('‚è±Ô∏è  [SOLVER] Step 1: Generating all 5-card combinations...');
  const step1Start = Date.now();
  const fiveCardHands = [];
  for (const indices of combinations(numCards, 5)) {
    const hand = indices.map((i) => parsedCards[i]);
    const ev = evalHand(hand);
    fiveCardHands.push({ indices: [...indices], hand, ev, backRoyalty: getRoyalties(ev, "back"), middleRoyalty: getRoyalties(ev, "middle") });
  }
  console.log('‚úÖ [SOLVER] Step 1 complete:', fiveCardHands.length, 'five-card hands generated in', (Date.now() - step1Start), 'ms');
  
  console.log('‚è±Ô∏è  [SOLVER] Step 2: Building 3-card hand cache...');
  const step2Start = Date.now();
  const threeCardHandCache = new Map();
  for (const indices of combinations(numCards, 3)) {
    const key = [...indices].sort((a, b) => a - b).join(",");
    const hand = indices.map((i) => parsedCards[i]);
    const ev = evalHand(hand);
    threeCardHandCache.set(key, { indices: [...indices], hand, ev, frontRoyalty: getRoyalties(ev, "front") });
  }
  console.log('‚úÖ [SOLVER] Step 2 complete:', threeCardHandCache.size, 'three-card hands cached in', (Date.now() - step2Start), 'ms');
  
  console.log('‚è±Ô∏è  [SOLVER] Step 3: Sorting five-card hands...');
  const step3Start = Date.now();
  fiveCardHands.sort((a, b) => compareHands(b.ev, a.ev));
  console.log('‚úÖ [SOLVER] Step 3 complete: Sorted in', (Date.now() - step3Start), 'ms');
  
  const allCardIndices = Array.from({ length: numCards }, (_, i) => i);
  const MAX_FRONT_ROYALTY = 22;
  
  console.log('‚è±Ô∏è  [SOLVER] Step 4: Main search loop (this is the heavy part)...');
  const step4Start = Date.now();
  let pairCount = 0;
  let validArrangements = 0;
  
  for (let i = 0; i < fiveCardHands.length; i++) {
    const backHand = fiveCardHands[i];
    
    // Progress logging every 100 back hands
    if (i % 100 === 0 && i > 0) {
      console.log(`   [SOLVER] Progress: ${i}/${fiveCardHands.length} back hands processed (${validArrangements} valid arrangements found)`);
    }
    
    for (let j = i; j < fiveCardHands.length; j++) {
      pairCount++;
      const middleHand = fiveCardHands[j];
      const currentBestScore = bestOverallArrangement?.points ?? -1;
      if (backHand.backRoyalty + middleHand.middleRoyalty + MAX_FRONT_ROYALTY < currentBestScore) continue;
      if (!areDisjoint(backHand.indices, middleHand.indices)) continue;
      const usedIndices = new Set([...backHand.indices, ...middleHand.indices]);
      const remainingIndices = allCardIndices.filter((idx) => !usedIndices.has(idx));
      let bestFrontForPair = null;
      for (const frontIndices of combinations(remainingIndices.length, 3)) {
        const actualFrontIndices = frontIndices.map(idx => remainingIndices[idx]);
        const key = actualFrontIndices.sort((a, b) => a - b).join(",");
        const frontHand = threeCardHandCache.get(key);
        if (compareHands(middleHand.ev, frontHand.ev) >= 0) {
          if (!bestFrontForPair || frontHand.frontRoyalty > bestFrontForPair.frontRoyalty) {
            bestFrontForPair = frontHand;
          } else if (frontHand.frontRoyalty === bestFrontForPair.frontRoyalty) {
            if (compareHands(frontHand.ev, bestFrontForPair.ev) > 0) {
              bestFrontForPair = frontHand;
            }
          }
        }
      }
      if (bestFrontForPair) {
        validArrangements++;
        const points = backHand.backRoyalty + middleHand.middleRoyalty + bestFrontForPair.frontRoyalty;
        const currentArrangement = { points, backEv: backHand.ev, middleEv: middleHand.ev, frontEv: bestFrontForPair.ev, backData: backHand, middleData: middleHand, frontData: bestFrontForPair };
        if (!bestOverallArrangement || points > bestOverallArrangement.points) {
          bestOverallArrangement = currentArrangement;
        } else if (points === bestOverallArrangement.points) {
          const frontComp = compareHands(currentArrangement.frontEv, bestOverallArrangement.frontEv);
          if (frontComp > 0) {
            bestOverallArrangement = currentArrangement;
          } else if (frontComp === 0) {
            const midComp = compareHands(currentArrangement.middleEv, bestOverallArrangement.middleEv);
            if (midComp > 0) {
              bestOverallArrangement = currentArrangement;
            } else if (midComp === 0) {
              if (compareHands(currentArrangement.backEv, bestOverallArrangement.backEv) > 0) {
                bestOverallArrangement = currentArrangement;
              }
            }
          }
        }
        const isRepeat = isRepeatFantasyland(backHand.ev, middleHand.ev, bestFrontForPair.ev);
        if (isRepeat) {
          if (!bestRepeatArrangement || points > bestRepeatArrangement.points) {
            bestRepeatArrangement = currentArrangement;
          } else if (points === bestRepeatArrangement.points) {
            const frontComp = compareHands(currentArrangement.frontEv, bestRepeatArrangement.frontEv);
            if (frontComp > 0) {
              bestRepeatArrangement = currentArrangement;
            } else if (frontComp === 0) {
              const midComp = compareHands(currentArrangement.middleEv, bestRepeatArrangement.middleEv);
              if (midComp > 0) {
                bestRepeatArrangement = currentArrangement;
              } else if (midComp === 0) {
                if (compareHands(currentArrangement.backEv, bestRepeatArrangement.backEv) > 0) {
                  bestRepeatArrangement = currentArrangement;
                }
              }
            }
          }
        }
      }
    }
  }
  console.log('‚úÖ [SOLVER] Step 4 complete: Evaluated', pairCount, 'back/middle pairs,', validArrangements, 'valid arrangements in', (Date.now() - step4Start), 'ms');
  
  if (!bestOverallArrangement) {
    console.log('‚ùå [SOLVER] No valid arrangement found!');
    return { best: null };
  }
  
  console.log('‚è±Ô∏è  [SOLVER] Step 5: Final selection and formatting...');
  const step5Start = Date.now();
  const overallScore = bestOverallArrangement.points;
  const repeatEVScore = bestRepeatArrangement ? bestRepeatArrangement.points + 8.25 : -1;
  let finalChoice = bestOverallArrangement;
  let isRepeatChoice = false;
  let finalPoints = overallScore;
  if (repeatEVScore > overallScore) {
    finalChoice = bestRepeatArrangement;
    isRepeatChoice = true;
    finalPoints = repeatEVScore;
  }
  const finalUsedIndices = new Set([...finalChoice.backData.indices, ...finalChoice.middleData.indices, ...finalChoice.frontData.indices]);
  const discardIndices = allCardIndices.filter(i => !finalUsedIndices.has(i));

  const sortByRankDesc = (cards) =>
    [...cards].sort((a, b) => b.rank - a.rank).map((c) => c.str);

  const bestResult = { 
    points: finalChoice.points,
    finalEV: finalPoints,
    isRepeat: isRepeatChoice,
    discards: sortByRankDesc(discardIndices.map((i) => parsedCards[i])),
    front: sortByRankDesc(finalChoice.frontData.hand),
    middle: sortByRankDesc(finalChoice.middleData.hand),
    back: sortByRankDesc(finalChoice.backData.hand)
  };
  
  console.log('‚úÖ [SOLVER] Step 5 complete in', (Date.now() - step5Start), 'ms');
  console.log('üéâ [SOLVER] TOTAL SOLVER TIME:', (Date.now() - solverStartTime), 'ms');
  console.log('üìä [SOLVER] Best score:', bestResult.finalEV, 'points', isRepeatChoice ? '(Repeat FL)' : '');

  return { best: bestResult };
}

module.exports = { solveOptimizedV2, parseCard };
```

===== FILE: src/index.js =====

```
// src/index.js

const TelegramBot = require('node-telegram-bot-api');
const { performance } = require('perf_hooks');
const { solveOptimizedV2, parseCard } = require('./solver/solver.js');
const geminiService = require('./services/gemini.service.js');
const mistralService = require('./services/mistral.service.js');

// ========== NEW CODE START: HTTP Server for Render ==========
const express = require('express');
const app = express();

// Simple health check endpoint to keep Render happy
app.get('/', (req, res) => {
    res.send('üöÄ FL Solver Bot is alive and solving poker hands!');
});

// Start the HTTP server on the port Render assigns
const PORT = process.env.PORT || 10000;
app.listen(PORT, '0.0.0.0', () => {
    console.log(`üåê Health check server running on port ${PORT}`);
});
// ========== NEW CODE END: HTTP Server for Render ==========

const token = process.env.TELEGRAM_BOT_TOKEN;

if (!token) {
    console.error('Error: TELEGRAM_BOT_TOKEN is not set!');
    process.exit(1);
}
if (!process.env.GEMINI_API_KEY) {
    console.error('Error: GEMINI_API_KEY is not set!');
    process.exit(1);
}
if (!process.env.MISTRAL_API_KEY) {
    console.error('Error: MISTRAL_API_KEY is not set!');
    process.exit(1);
}

const bot = new TelegramBot(token, { polling: true });

// ========== MODEL MANAGEMENT ==========

// Create a unified model config by merging both services
function getAllModels() {
    const geminiModels = geminiService.getAvailableModels();
    const mistralModels = mistralService.getAvailableModels();
    
    // Add provider field to models
    const geminiWithProvider = {};
    for (const key in geminiModels) {
        geminiWithProvider[key] = {
            ...geminiModels[key],
            provider: 'gemini'
        };
    }
    
    const mistralWithProvider = {};
    for (const key in mistralModels) {
        mistralWithProvider[key] = {
            ...mistralModels[key],
            provider: 'mistral'
        };
    }
    
    return { ...geminiWithProvider, ...mistralWithProvider };
}

// Track current provider and model
let currentProvider = 'gemini';
let currentModelKey = 'pro';

function setCurrentModel(modelKey) {
    const allModels = getAllModels();
    const model = allModels[modelKey];
    
    if (!model) return false;
    
    currentProvider = model.provider;
    currentModelKey = modelKey;
    
    // Set the model in the appropriate service
    if (currentProvider === 'gemini') {
        return geminiService.setModel(modelKey);
    } else if (currentProvider === 'mistral') {
        return mistralService.setModel(modelKey);
    }
    
    return false;
}

function getCurrentModel() {
    if (currentProvider === 'gemini') {
        return { ...geminiService.getCurrentModel(), provider: 'gemini' };
    } else if (currentProvider === 'mistral') {
        return { ...mistralService.getCurrentModel(), provider: 'mistral' };
    }
}

// Route to the correct service based on current provider
async function identifyCardsFromImage(imageBuffer) {
    if (currentProvider === 'gemini') {
        return geminiService.identifyCardsFromImage(imageBuffer);
    } else if (currentProvider === 'mistral') {
        return mistralService.identifyCardsFromImage(imageBuffer);
    }
    throw new Error('Unknown provider');
}

// ========== UTILITY FUNCTIONS ==========

/**
 * Formats a card string with a colored emoji for its suit.
 * @param {string} cardStr - e.g., "AS", "KH", "TD"
 * @returns {string} - e.g., "A‚ô†Ô∏è", "K‚ù§Ô∏è", "Tüî∑"
 */
function formatCardWithColor(cardStr) {
    if (!cardStr || cardStr.length < 2) return cardStr;
    const rank = cardStr.slice(0, -1);
    const suit = cardStr.slice(-1);
    switch (suit) {
        case '‚ô†': return rank + '‚ô†Ô∏è';
        case '‚ô•': return rank + '‚ù§Ô∏è';
        case '‚ô¶': return rank + 'üî∑';
        case '‚ô£': return rank + 'üü¢';
        default: return cardStr;
    }
}

// --- Reusable Solver Function ---
async function runSolverAndReply(chatId, cardString) {
    try {
        const cardCodes = cardString.trim().split(/\s+/);
        const numCards = cardCodes.length;

        if (numCards < 14 || numCards > 17) {
            bot.sendMessage(chatId, `‚ùå *Error:* I found ${numCards} cards, but I can only solve for 14, 15, 16, or 17. Please try a clearer screenshot.`, { parse_mode: 'Markdown' });
            return;
        }

        const parsedCards = cardCodes.map(parseCard);
        const invalidCards = parsedCards.filter(c => c === null);

        if (invalidCards.length > 0) {
            bot.sendMessage(chatId, `‚ùå *Error:* I couldn't understand some of the cards identified. The model might have made a mistake. Please try again.`, { parse_mode: 'Markdown' });
            return;
        }

        const startTime = performance.now();
        const { best } = solveOptimizedV2(parsedCards);
        const endTime = performance.now();
        const solveTime = ((endTime - startTime) / 1000).toFixed(3);

        if (!best) {
            bot.sendMessage(chatId, "Couldn't find a valid arrangement. This is unexpected!");
            return;
        }

        const repeatText = best.isRepeat ? '‚úÖ (Repeat Fantasyland EV)' : '';

        // Apply the new color formatting to all card arrays
        const frontFormatted = best.front.map(formatCardWithColor).join(' ');
        const middleFormatted = best.middle.map(formatCardWithColor).join(' ');
        const backFormatted = best.back.map(formatCardWithColor).join(' ');
        const discardsFormatted = best.discards.map(formatCardWithColor).join(' ');

        const resultMessage = `*Optimal Arrangement Found!*

\`${frontFormatted}\`
\`${middleFormatted}\`
\`${backFormatted}\`

*Discards:* \`${discardsFormatted}\`

*Score:* ${best.finalEV.toFixed(2)} pts ${repeatText}
*Time:* ${solveTime} seconds (solver)
        `;
        bot.sendMessage(chatId, resultMessage, { parse_mode: 'Markdown' });

    } catch (error) {
        console.error("Solver Error:", error);
        bot.sendMessage(chatId, "An unexpected error occurred while solving. Please check the server logs.");
    }
}

// ========== BOT COMMANDS ==========

// --- /start command ---
bot.onText(/\/start/, (msg) => {
    const chatId = msg.chat.id;
    const currentModel = getCurrentModel();
    const startMessage = `Hello! üëã Just send me a screenshot of your cards, and I'll find the optimal arrangement for you.

*Current Vision Model:* ${currentModel.displayName}
*Available Commands:*
/model - Switch vision model
/pro - Gemini 2.5 Pro
/flash - Gemini Flash
/mistrallarge - Mistrall Large
`;
    bot.sendMessage(chatId, startMessage, { parse_mode: 'Markdown' });
});

// --- /solve command (for text input) ---
bot.onText(/\/solve (.+)/, (msg, match) => {
    runSolverAndReply(msg.chat.id, match[1]);
});

// --- /model command (switch models) ---
bot.onText(/\/model/, (msg) => {
    const chatId = msg.chat.id;
    const allModels = getAllModels();
    // const currentModel = getCurrentModel();
    
    const keyboard = {
        inline_keyboard: Object.keys(allModels).map(key => [{
            text: `${allModels[key].displayName} (${allModels[key].provider})${key === currentModelKey ? ' ‚úì' : ''}`,
            callback_data: `model_${key}`
        }])
    };
    
    bot.sendMessage(chatId, '*Select Vision Model:*', { 
        parse_mode: 'Markdown',
        reply_markup: keyboard 
    });
});

// --- /status command ---
bot.onText(/\/status/, (msg) => {
    const chatId = msg.chat.id;
    const currentModel = getCurrentModel();
    
    const statusMessage = `*Current Bot Settings:*

*Vision Model:* ${currentModel.displayName}
*Provider:* ${currentModel.provider}
*Model ID:* \`${currentModel.name}\`

Use /model to switch models.
`;
    bot.sendMessage(chatId, statusMessage, { parse_mode: 'Markdown' });
});

// --- Direct command handlers for Gemini models ---

bot.onText(/\/flash/, (msg) => {
    const chatId = msg.chat.id;
    const success = setCurrentModel('flash');
    
    if (success) {
        const newModel = getCurrentModel();
        bot.sendMessage(chatId, `‚úÖ *Vision model changed to:* ${newModel.displayName}`, { parse_mode: 'Markdown' });
    } else {
        bot.sendMessage(chatId, '‚ùå Error switching model');
    }
});

bot.onText(/\/pro/, (msg) => {
    const chatId = msg.chat.id;
    const success = setCurrentModel('pro');
    
    if (success) {
        const newModel = getCurrentModel();
        bot.sendMessage(chatId, `‚úÖ *Vision model changed to:* ${newModel.displayName}`, { parse_mode: 'Markdown' });
    } else {
        bot.sendMessage(chatId, '‚ùå Error switching model');
    }
});

// --- Direct command handlers for Mistral models ---
bot.onText(/\/mistrallarge/, (msg) => {
    const chatId = msg.chat.id;
    const success = setCurrentModel('mistral-large');
    
    if (success) {
        const newModel = getCurrentModel();
        bot.sendMessage(chatId, `‚úÖ *Vision model changed to:* ${newModel.displayName}`, { parse_mode: 'Markdown' });
    } else {
        bot.sendMessage(chatId, '‚ùå Error switching model');
    }
});
bot.onText(/\/mistralsmall/, (msg) => {
    const chatId = msg.chat.id;
    const success = setCurrentModel('mistral-small');
    
    if (success) {
        const newModel = getCurrentModel();
        bot.sendMessage(chatId, `‚úÖ *Vision model changed to:* ${newModel.displayName}`, { parse_mode: 'Markdown' });
    } else {
        bot.sendMessage(chatId, '‚ùå Error switching model');
    }
});

// --- Handle model selection callbacks ---
bot.on('callback_query', (query) => {
    const chatId = query.message.chat.id;
    const data = query.data;
    
    if (data.startsWith('model_')) {
        const modelKey = data.replace('model_', '');
        const success = setCurrentModel(modelKey);
        
        if (success) {
            const newModel = getCurrentModel();
            bot.answerCallbackQuery(query.id, { text: `Switched to ${newModel.displayName}` });
            bot.editMessageText(`‚úÖ *Vision model changed to:* ${newModel.displayName} (${newModel.provider})`, {
                chat_id: chatId,
                message_id: query.message.message_id,
                parse_mode: 'Markdown'
            });
        } else {
            bot.answerCallbackQuery(query.id, { text: 'Error switching model' });
        }
    }
});

// --- Photo Handler (for image input) ---
bot.on('photo', async (msg) => {
    const chatId = msg.chat.id;

    try {
        // Let the user know the bot is working
        bot.sendChatAction(chatId, 'typing');

        // Get the highest resolution photo
        const photo = msg.photo[msg.photo.length - 1];
        const fileStream = bot.getFileStream(photo.file_id);

        // Download the image into a buffer
        const chunks = [];
        for await (const chunk of fileStream) {
            chunks.push(chunk);
        }
        const imageBuffer = Buffer.concat(chunks);

        // Call the appropriate vision service to identify cards
        const cardStringFromVision = await identifyCardsFromImage(imageBuffer);

        if (!cardStringFromVision) {
            await bot.sendMessage(chatId, "Sorry, I couldn't extract the cards from that image. Please try a clearer screenshot without any obstructions.");
            return;
        }

        // Send the extracted cards immediately
        // await bot.sendMessage(chatId, `üìã *Cards identified:*\n\`/solve ${cardStringFromVision}\``, { parse_mode: 'MarkdownV2' });

        // Run the solver with the identified cards and send the final reply
        await runSolverAndReply(chatId, cardStringFromVision);

    } catch (error) {
        console.error("Photo Handler Error:", error);
        await bot.sendMessage(chatId, "An error occurred while processing your image. Please try again.");
    }
});

console.log('üöÄ FL Solver Bot is running and listening for commands and photos!');

bot.on('polling_error', (error) => {
    console.error('Polling error:', error.code);
});
```

This Telegram bot automatically redeploys to Render.com whenever new code is pushed to the GitHub repo.

Development and testing are done in GitHub Codespaces using the same repo and secrets (except for the Telegram bot token). This allows live testing directly from the browser IDE while interacting with a separate Telegram bot instance in the app.

To run locally:
`node src/index.js`

# Overview

The bot is a Fantasyland Poker solver that supports all variants (14‚Äì17 cards). It processes screenshots from any poker app where the hero is in Fantasyland mode. The image is analyzed using a vision-language model to identify visible cards, which are then passed to the solver for optimal hand arrangement.

**Flow:**
Screenshot ‚Üí Telegram API (image) ‚Üí Base64 ‚Üí Vision model (cards ‚Üí text) ‚Üí Solver ‚Üí Formatted solution ‚Üí Telegram API (send reply)

# Files

```
FLSOLVERBOT
‚îú‚îÄ‚îÄ node_modules
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ services
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ gemini.service.js
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ mistral.service.js
‚îÇ   ‚îú‚îÄ‚îÄ solver
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ solver.js
‚îÇ   ‚îî‚îÄ‚îÄ index.js
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ TODO.md
```
# Codebase

===== FILE: src/services/mistral.service.js =====

```
// src/services/mistral.service.js

const { Mistral } = require("@mistralai/mistralai");

// Initialize the Mistral client
const client = new Mistral({
    apiKey: process.env.MISTRAL_API_KEY,
});

const temperature = 0;
const systemInstruction = `You are analyzing a screenshot of a poker app showing several playing cards face up in a row. Your job is to identify them and output them in standard poker notation.

STEP 1 - CAREFULLY IDENTIFY EACH CARD:
From the row of visible playing cards, starting from the first card on the left, list each card writing out the rank and suit in words.
Format:
1. [rank], [suit]
2. [rank], [suit]
etc.

STEP 2 - CONVERT TO STANDARD NOTATION:
Use this exact notation system:
- RANKS: 2 3 4 5 6 7 8 9 T J Q K A
- SUITS: C = Clubs, D = Diamonds, H = Hearts, S = Spades

CRITICAL: 
- Ten is ALWAYS written as 'T', NEVER as '10'
- Each card is exactly 2 characters: rank + suit
- Example: TC = Ten of Clubs, 9H = Nine of Hearts, AS = Ace of Spades

STEP 3 - OUTPUT:
Provide all cards in a single line, separated by single spaces, enclosed in triple backticks.
- Example:
\`\`\`9C TD 6S QH\`\`\`
`;

// Model configurations - easy to add new models here
const MODEL_CONFIGS = {
    'mistral-large': {
        name: 'mistral-large-latest',
        displayName: 'Mistral Large',
    },
    'mistral-small': {
        name: 'mistral-small-latest',
        displayName: 'mistral Small',
    },
};

// Default model
let currentModelKey = 'mistral-small';

/**
 * Sets the current model to use
 * @param {string} modelKey - Key from MODEL_CONFIGS
 * @returns {boolean} - True if model was set successfully
 */
function setModel(modelKey) {
    if (MODEL_CONFIGS[modelKey]) {
        currentModelKey = modelKey;
        return true;
    }
    return false;
}

/**
 * Gets the current model configuration
 * @returns {object} - Current model config
 */
function getCurrentModel() {
    return MODEL_CONFIGS[currentModelKey];
}

/**
 * Gets all available models
 * @returns {object} - All model configurations
 */
function getAvailableModels() {
    return MODEL_CONFIGS;
}

/**
 * Identifies cards from an image buffer using Mistral Vision.
 * @param {Buffer} imageBuffer The image data as a buffer.
 * @returns {Promise<string|null>} A string of card codes, or null if parsing fails.
 */
async function identifyCardsFromImage(imageBuffer) {
    try {
        const modelConfig = MODEL_CONFIGS[currentModelKey];
        
        // Convert buffer to base64
        const base64Image = imageBuffer.toString('base64');
        const base64DataUrl = `data:image/jpeg;base64,${base64Image}`;

        const chatResponse = await client.chat.complete({
            model: modelConfig.name,
            temperature: temperature,
            messages: [
                {
                    role: "system",
                    content: systemInstruction,
                },
                {
                    role: "user",
                    content: [
                        {
                            type: "image_url",
                            imageUrl: base64DataUrl,
                        },
                    ],
                },
            ],
        });

        const responseText = chatResponse.choices[0].message.content;

        // Extract the content from between the triple backticks
        const match = responseText.match(/\`\`\`([\s\S]*?)\`\`\`/);

        if (match && match[1]) {
            // Return the cleaned, trimmed string of cards
            return match[1].trim();
        } else {
            console.error("Mistral response did not contain the expected format:", responseText);
            return null;
        }

    } catch (error) {
        console.error("Error calling Mistral API:", error);
        throw new Error("Failed to get a valid response from the vision model.");
    }
}

module.exports = { 
    identifyCardsFromImage, 
    setModel, 
    getCurrentModel, 
    getAvailableModels 
};

```

===== FILE: src/services/gemini.service.js =====

```
// src/services/gemini.service.js

const { GoogleGenAI } = require("@google/genai");

// Initialize the Gemini client
const ai = new GoogleGenAI({
    apiKey: process.env.GEMINI_API_KEY,
});

const temperature = 0;
const systemInstruction = `You are analyzing a screenshot of a poker app showing several playing cards face up in a row. Your job is to identify them and output them in standard poker notation.

STEP 1 - CAREFULLY IDENTIFY EACH CARD:
From the row of visible playing cards, starting from the first card on the left, list each card writing out the rank and suit in words.
Format:
1. [rank], [suit]
2. [rank], [suit]
etc.

STEP 2 - CONVERT TO STANDARD NOTATION:
Use this exact notation system:
- RANKS: 2 3 4 5 6 7 8 9 T J Q K A
- SUITS: C = Clubs, D = Diamonds, H = Hearts, S = Spades

CRITICAL: 
- Ten is ALWAYS written as 'T', NEVER as '10'
- Each card is exactly 2 characters: rank + suit
- Example: TC = Ten of Clubs, 9H = Nine of Hearts, AS = Ace of Spades

STEP 3 - OUTPUT:
Provide all cards in a single line, separated by single spaces, enclosed in triple backticks.
- Example:
\`\`\`9C TD 6S QH\`\`\`
`;

// Model configurations - easy to add new models here
const MODEL_CONFIGS = {
    'pro': {
        provider: 'gemini', 
        name: 'gemini-2.5-pro',
        displayName: 'Gemini 2.5 Pro',
        thinkingBudget: -1,
    },
        'flash': {
        provider: 'gemini',  
        name: 'gemini-flash-latest',
        displayName: 'Gemini Flash',
        thinkingBudget: -1,
    },
    // ... any other gemini models
};

// Default model
let currentModelKey = 'pro';

/**
 * Sets the current model to use
 * @param {string} modelKey - Key from MODEL_CONFIGS
 * @returns {boolean} - True if model was set successfully
 */
function setModel(modelKey) {
    if (MODEL_CONFIGS[modelKey]) {
        currentModelKey = modelKey;
        return true;
    }
    return false;
}

/**
 * Gets the current model configuration
 * @returns {object} - Current model config
 */
function getCurrentModel() {
    return MODEL_CONFIGS[currentModelKey];
}

/**
 * Gets all available models
 * @returns {object} - All model configurations
 */
function getAvailableModels() {
    return MODEL_CONFIGS;
}

/**
 * Identifies cards from an image buffer using Gemini Vision.
 * @param {Buffer} imageBuffer The image data as a buffer.
 * @returns {Promise<string|null>} A string of card codes, or null if parsing fails.
 */
async function identifyCardsFromImage(imageBuffer) {
    try {
        const modelConfig = MODEL_CONFIGS[currentModelKey];
        
        const config = {
            temperature: temperature,
            thinkingConfig: {
                thinkingBudget: modelConfig.thinkingBudget,
            },
            systemInstruction: [
                {
                    text: systemInstruction,
                }
            ],
        };

        const contents = [
            {
                role: 'user',
                parts: [
                    {
                        inlineData: {
                            mimeType: 'image/jpeg',
                            data: imageBuffer.toString("base64"),
                        },
                    },
                ],
            },
        ];

        const response = await ai.models.generateContent({
            model: modelConfig.name,
            config,
            contents,
        });

        const responseText = response.text;

        // Extract the content from between the triple backticks
        const match = responseText.match(/\`\`\`([\s\S]*?)\`\`\`/);

        if (match && match[1]) {
            // Return the cleaned, trimmed string of cards
            return match[1].trim();
        } else {
            console.error("Gemini response did not contain the expected format:", responseText);
            return null;
        }

    } catch (error) {
        console.error("Error calling Gemini API:", error);
        throw new Error("Failed to get a valid response from the vision model.");
    }
}

module.exports = { 
    identifyCardsFromImage, 
    setModel, 
    getCurrentModel, 
    getAvailableModels 
};
```

===== FILE: src/solver/solver.js =====

```
// src/solver/solver.js

const RANKS = ["2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"];
const SUITS = ["‚ô†Ô∏è", "‚ù§Ô∏è", "üî∑", "üü¢"];
const SUIT_MAP = { "‚ô†Ô∏è": 0, "‚ù§Ô∏è": 1, "üî∑": 2, "üü¢": 3, S: 0, H: 1, D: 2, C: 3 };

function parseCard(code) {
  if (!code || code.length < 2) return null;
  const c = code.trim().toUpperCase();
  const r = c[0];
  const sRaw = c.slice(1);
  const rank = RANKS.indexOf(r);
  const suit = SUIT_MAP[sRaw];
  if (rank === -1 || suit === undefined) return null;
  return { rank, suit, str: r + SUITS[suit] };
}

function evalHand(hand) {
  const len = hand.length;
  const ranks = new Array(13).fill(0);
  const suits = new Array(4).fill(0);
  let handRanks = [];
  for (let i = 0; i < len; i++) {
    ranks[hand[i].rank]++;
    suits[hand[i].suit]++;
    handRanks.push(hand[i].rank);
  }
  handRanks.sort((a, b) => b - a);
  const isFlush = suits.some((count) => count >= 5);
  const groups = [];
  for (let i = 12; i >= 0; i--) {
    if (ranks[i] > 0) groups.push([i, ranks[i]]);
  }
  groups.sort((a, b) => b[1] - a[1]);
  let straightHigh = -1;
  const uniqueRanks = [...new Set(handRanks)].sort((a, b) => a - b);
  if (uniqueRanks.length >= 5) {
    if (uniqueRanks.includes(12) && uniqueRanks.includes(0) && uniqueRanks.includes(1) && uniqueRanks.includes(2) && uniqueRanks.includes(3)) {
      straightHigh = 3;
    } else {
      for (let i = uniqueRanks.length - 1; i >= 4; i--) {
        if (uniqueRanks[i] - uniqueRanks[i - 4] === 4) {
          straightHigh = uniqueRanks[i];
          break;
        }
      }
    }
  }
  if (len === 5) {
    if (straightHigh !== -1 && isFlush) return { cat: 8, kickers: [straightHigh] };
    if (groups[0][1] === 4) return { cat: 7, kickers: [groups[0][0], groups[1]?.[0]] };
    if (groups[0][1] === 3 && groups[1][1] === 2) return { cat: 6, kickers: [groups[0][0], groups[1][0]] };
    if (isFlush) return { cat: 5, kickers: handRanks };
    if (straightHigh !== -1) return { cat: 4, kickers: [straightHigh] };
    if (groups[0][1] === 3) return { cat: 3, kickers: [groups[0][0], ...handRanks.filter((r) => r !== groups[0][0])] };
    if (groups[0][1] === 2 && groups[1][1] === 2) return { cat: 2, kickers: [groups[0][0], groups[1][0], groups[2]?.[0]] };
    if (groups[0][1] === 2) return { cat: 1, kickers: [groups[0][0], ...handRanks.filter((r) => r !== groups[0][0])] };
    return { cat: 0, kickers: handRanks };
  } else {
    if (groups[0][1] === 3) return { cat: 3, kickers: [groups[0][0]] };
    if (groups[0][1] === 2) return { cat: 1, kickers: [groups[0][0], groups[1]?.[0]] };
    return { cat: 0, kickers: handRanks };
  }
}

function compareHands(evalA, evalB) {
  if (evalA.cat !== evalB.cat) return evalA.cat - evalB.cat;
  for (let i = 0; i < evalA.kickers.length; i++) {
    if (evalA.kickers[i] !== evalB.kickers[i]) {
      return evalA.kickers[i] - evalB.kickers[i];
    }
  }
  return 0;
}

const defaultRoyalties = {
  back: { 4: 2, 5: 4, 6: 6, 7: 10, 8: 15 },
  middle: { 3: 2, 4: 4, 5: 8, 6: 12, 7: 20, 8: 30 },
  frontPairs: { 4: 1, 5: 2, 6: 3, 7: 4, 8: 5, 9: 6, 10: 7, 11: 8, 12: 9 },
  frontTripsBase: 10,
};

function getRoyalties(ev, tier) {
  if (tier === "back") return defaultRoyalties.back[ev.cat] || 0;
  if (tier === "middle") return defaultRoyalties.middle[ev.cat] || 0;
  if (tier === "front") {
    if (ev.cat === 3) return defaultRoyalties.frontTripsBase + ev.kickers[0];
    if (ev.cat === 1) return defaultRoyalties.frontPairs[ev.kickers[0]] || 0;
  }
  return 0;
}

function* combinations(n, k) {
  if (k > n || k < 0) return;
  const indices = Array.from({ length: k }, (_, i) => i);
  while (true) {
    yield indices;
    let i = k - 1;
    while (i >= 0 && indices[i] === i + n - k) i--;
    if (i < 0) return;
    indices[i]++;
    for (let j = i + 1; j < k; j++) indices[j] = indices[j - 1] + 1;
  }
}

function isRepeatFantasyland(backEv, middleEv, frontEv) {
  if (backEv.cat >= 7) return true;
  if (middleEv.cat >= 6) return true;
  if (frontEv.cat === 3) return true;
  return false;
}

function areDisjoint(indicesA, indicesB) {
  const setA = new Set(indicesA);
  for (const index of indicesB) {
    if (setA.has(index)) return false;
  }
  return true;
}

function solveOptimizedV2(parsedCards) {
  console.log('üîç [SOLVER] Starting solver with', parsedCards.length, 'cards');
  const solverStartTime = Date.now();
  
  const numCards = parsedCards.length;
  if (numCards < 13) throw new Error("Solver requires at least 13 cards.");
  
  let bestOverallArrangement = null;
  let bestRepeatArrangement = null;
  
  console.log('‚è±Ô∏è  [SOLVER] Step 1: Generating all 5-card combinations...');
  const step1Start = Date.now();
  const fiveCardHands = [];
  for (const indices of combinations(numCards, 5)) {
    const hand = indices.map((i) => parsedCards[i]);
    const ev = evalHand(hand);
    fiveCardHands.push({ indices: [...indices], hand, ev, backRoyalty: getRoyalties(ev, "back"), middleRoyalty: getRoyalties(ev, "middle") });
  }
  console.log('‚úÖ [SOLVER] Step 1 complete:', fiveCardHands.length, 'five-card hands generated in', (Date.now() - step1Start), 'ms');
  
  console.log('‚è±Ô∏è  [SOLVER] Step 2: Building 3-card hand cache...');
  const step2Start = Date.now();
  const threeCardHandCache = new Map();
  for (const indices of combinations(numCards, 3)) {
    const key = [...indices].sort((a, b) => a - b).join(",");
    const hand = indices.map((i) => parsedCards[i]);
    const ev = evalHand(hand);
    threeCardHandCache.set(key, { indices: [...indices], hand, ev, frontRoyalty: getRoyalties(ev, "front") });
  }
  console.log('‚úÖ [SOLVER] Step 2 complete:', threeCardHandCache.size, 'three-card hands cached in', (Date.now() - step2Start), 'ms');
  
  console.log('‚è±Ô∏è  [SOLVER] Step 3: Sorting five-card hands...');
  const step3Start = Date.now();
  fiveCardHands.sort((a, b) => compareHands(b.ev, a.ev));
  console.log('‚úÖ [SOLVER] Step 3 complete: Sorted in', (Date.now() - step3Start), 'ms');
  
  const allCardIndices = Array.from({ length: numCards }, (_, i) => i);
  const MAX_FRONT_ROYALTY = 22;
  
  console.log('‚è±Ô∏è  [SOLVER] Step 4: Main search loop (this is the heavy part)...');
  const step4Start = Date.now();
  let pairCount = 0;
  let validArrangements = 0;
  
  for (let i = 0; i < fiveCardHands.length; i++) {
    const backHand = fiveCardHands[i];
    
    // Progress logging every 100 back hands
    if (i % 100 === 0 && i > 0) {
      console.log(`   [SOLVER] Progress: ${i}/${fiveCardHands.length} back hands processed (${validArrangements} valid arrangements found)`);
    }
    
    for (let j = i; j < fiveCardHands.length; j++) {
      pairCount++;
      const middleHand = fiveCardHands[j];
      const currentBestScore = bestOverallArrangement?.points ?? -1;
      if (backHand.backRoyalty + middleHand.middleRoyalty + MAX_FRONT_ROYALTY < currentBestScore) continue;
      if (!areDisjoint(backHand.indices, middleHand.indices)) continue;
      const usedIndices = new Set([...backHand.indices, ...middleHand.indices]);
      const remainingIndices = allCardIndices.filter((idx) => !usedIndices.has(idx));
      let bestFrontForPair = null;
      for (const frontIndices of combinations(remainingIndices.length, 3)) {
        const actualFrontIndices = frontIndices.map(idx => remainingIndices[idx]);
        const key = actualFrontIndices.sort((a, b) => a - b).join(",");
        const frontHand = threeCardHandCache.get(key);
        if (compareHands(middleHand.ev, frontHand.ev) >= 0) {
          if (!bestFrontForPair || frontHand.frontRoyalty > bestFrontForPair.frontRoyalty) {
            bestFrontForPair = frontHand;
          } else if (frontHand.frontRoyalty === bestFrontForPair.frontRoyalty) {
            if (compareHands(frontHand.ev, bestFrontForPair.ev) > 0) {
              bestFrontForPair = frontHand;
            }
          }
        }
      }
      if (bestFrontForPair) {
        validArrangements++;
        const points = backHand.backRoyalty + middleHand.middleRoyalty + bestFrontForPair.frontRoyalty;
        const currentArrangement = { points, backEv: backHand.ev, middleEv: middleHand.ev, frontEv: bestFrontForPair.ev, backData: backHand, middleData: middleHand, frontData: bestFrontForPair };
        if (!bestOverallArrangement || points > bestOverallArrangement.points) {
          bestOverallArrangement = currentArrangement;
        } else if (points === bestOverallArrangement.points) {
          const frontComp = compareHands(currentArrangement.frontEv, bestOverallArrangement.frontEv);
          if (frontComp > 0) {
            bestOverallArrangement = currentArrangement;
          } else if (frontComp === 0) {
            const midComp = compareHands(currentArrangement.middleEv, bestOverallArrangement.middleEv);
            if (midComp > 0) {
              bestOverallArrangement = currentArrangement;
            } else if (midComp === 0) {
              if (compareHands(currentArrangement.backEv, bestOverallArrangement.backEv) > 0) {
                bestOverallArrangement = currentArrangement;
              }
            }
          }
        }
        const isRepeat = isRepeatFantasyland(backHand.ev, middleHand.ev, bestFrontForPair.ev);
        if (isRepeat) {
          if (!bestRepeatArrangement || points > bestRepeatArrangement.points) {
            bestRepeatArrangement = currentArrangement;
          } else if (points === bestRepeatArrangement.points) {
            const frontComp = compareHands(currentArrangement.frontEv, bestRepeatArrangement.frontEv);
            if (frontComp > 0) {
              bestRepeatArrangement = currentArrangement;
            } else if (frontComp === 0) {
              const midComp = compareHands(currentArrangement.middleEv, bestRepeatArrangement.middleEv);
              if (midComp > 0) {
                bestRepeatArrangement = currentArrangement;
              } else if (midComp === 0) {
                if (compareHands(currentArrangement.backEv, bestRepeatArrangement.backEv) > 0) {
                  bestRepeatArrangement = currentArrangement;
                }
              }
            }
          }
        }
      }
    }
  }
  console.log('‚úÖ [SOLVER] Step 4 complete: Evaluated', pairCount, 'back/middle pairs,', validArrangements, 'valid arrangements in', (Date.now() - step4Start), 'ms');
  
  if (!bestOverallArrangement) {
    console.log('‚ùå [SOLVER] No valid arrangement found!');
    return { best: null };
  }
  
  console.log('‚è±Ô∏è  [SOLVER] Step 5: Final selection and formatting...');
  const step5Start = Date.now();
  const overallScore = bestOverallArrangement.points;
  const repeatEVScore = bestRepeatArrangement ? bestRepeatArrangement.points + 8.25 : -1;
  let finalChoice = bestOverallArrangement;
  let isRepeatChoice = false;
  let finalPoints = overallScore;
  if (repeatEVScore > overallScore) {
    finalChoice = bestRepeatArrangement;
    isRepeatChoice = true;
    finalPoints = repeatEVScore;
  }
  const finalUsedIndices = new Set([...finalChoice.backData.indices, ...finalChoice.middleData.indices, ...finalChoice.frontData.indices]);
  const discardIndices = allCardIndices.filter(i => !finalUsedIndices.has(i));

  const sortByRankDesc = (cards) =>
    [...cards].sort((a, b) => b.rank - a.rank).map((c) => c.str);

  const bestResult = { 
    points: finalChoice.points,
    finalEV: finalPoints,
    isRepeat: isRepeatChoice,
    discards: sortByRankDesc(discardIndices.map((i) => parsedCards[i])),
    front: sortByRankDesc(finalChoice.frontData.hand),
    middle: sortByRankDesc(finalChoice.middleData.hand),
    back: sortByRankDesc(finalChoice.backData.hand)
  };
  
  console.log('‚úÖ [SOLVER] Step 5 complete in', (Date.now() - step5Start), 'ms');
  console.log('üéâ [SOLVER] TOTAL SOLVER TIME:', (Date.now() - solverStartTime), 'ms');
  console.log('üìä [SOLVER] Best score:', bestResult.finalEV, 'points', isRepeatChoice ? '(Repeat FL)' : '');

  return { best: bestResult };
}

module.exports = { solveOptimizedV2, parseCard };
```

===== FILE: src/index.js =====

```
// src/index.js

const TelegramBot = require('node-telegram-bot-api');
const { performance } = require('perf_hooks');
const { solveOptimizedV2, parseCard } = require('./solver/solver.js');
const geminiService = require('./services/gemini.service.js');
const mistralService = require('./services/mistral.service.js');

// ========== NEW CODE START: HTTP Server for Render ==========
const express = require('express');
const app = express();

// Simple health check endpoint to keep Render happy
app.get('/', (req, res) => {
    res.send('üöÄ FL Solver Bot is alive and solving poker hands!');
});

// Start the HTTP server on the port Render assigns
const PORT = process.env.PORT || 10000;
app.listen(PORT, '0.0.0.0', () => {
    console.log(`üåê Health check server running on port ${PORT}`);
});
// ========== NEW CODE END: HTTP Server for Render ==========

const token = process.env.TELEGRAM_BOT_TOKEN;

if (!token) {
    console.error('Error: TELEGRAM_BOT_TOKEN is not set!');
    process.exit(1);
}
if (!process.env.GEMINI_API_KEY) {
    console.error('Error: GEMINI_API_KEY is not set!');
    process.exit(1);
}
if (!process.env.MISTRAL_API_KEY) {
    console.error('Error: MISTRAL_API_KEY is not set!');
    process.exit(1);
}

const bot = new TelegramBot(token, { polling: true });

// ========== MODEL MANAGEMENT ==========

// Create a unified model config by merging both services
function getAllModels() {
    const geminiModels = geminiService.getAvailableModels();
    const mistralModels = mistralService.getAvailableModels();
    
    // Add provider field to models
    const geminiWithProvider = {};
    for (const key in geminiModels) {
        geminiWithProvider[key] = {
            ...geminiModels[key],
            provider: 'gemini'
        };
    }
    
    const mistralWithProvider = {};
    for (const key in mistralModels) {
        mistralWithProvider[key] = {
            ...mistralModels[key],
            provider: 'mistral'
        };
    }
    
    return { ...geminiWithProvider, ...mistralWithProvider };
}

// Track current provider and model
let currentProvider = 'gemini';
let currentModelKey = 'pro';

function setCurrentModel(modelKey) {
    const allModels = getAllModels();
    const model = allModels[modelKey];
    
    if (!model) return false;
    
    currentProvider = model.provider;
    currentModelKey = modelKey;
    
    // Set the model in the appropriate service
    if (currentProvider === 'gemini') {
        return geminiService.setModel(modelKey);
    } else if (currentProvider === 'mistral') {
        return mistralService.setModel(modelKey);
    }
    
    return false;
}

function getCurrentModel() {
    if (currentProvider === 'gemini') {
        return { ...geminiService.getCurrentModel(), provider: 'gemini' };
    } else if (currentProvider === 'mistral') {
        return { ...mistralService.getCurrentModel(), provider: 'mistral' };
    }
}

// Route to the correct service based on current provider
async function identifyCardsFromImage(imageBuffer) {
    if (currentProvider === 'gemini') {
        return geminiService.identifyCardsFromImage(imageBuffer);
    } else if (currentProvider === 'mistral') {
        return mistralService.identifyCardsFromImage(imageBuffer);
    }
    throw new Error('Unknown provider');
}

// ========== UTILITY FUNCTIONS ==========

/**
 * Formats a card string with a colored emoji for its suit.
 * @param {string} cardStr - e.g., "AS", "KH", "TD"
 * @returns {string} - e.g., "A‚ô†Ô∏è", "K‚ù§Ô∏è", "Tüî∑"
 */
function formatCardWithColor(cardStr) {
    if (!cardStr || cardStr.length < 2) return cardStr;
    const rank = cardStr.slice(0, -1);
    const suit = cardStr.slice(-1);
    switch (suit) {
        case '‚ô†': return rank + '‚ô†Ô∏è';
        case '‚ô•': return rank + '‚ù§Ô∏è';
        case '‚ô¶': return rank + 'üî∑';
        case '‚ô£': return rank + 'üü¢';
        default: return cardStr;
    }
}

// --- Reusable Solver Function ---
async function runSolverAndReply(chatId, cardString) {
    try {
        const cardCodes = cardString.trim().split(/\s+/);
        const numCards = cardCodes.length;

        if (numCards < 14 || numCards > 17) {
            bot.sendMessage(chatId, `‚ùå *Error:* I found ${numCards} cards, but I can only solve for 14, 15, 16, or 17. Please try a clearer screenshot.`, { parse_mode: 'Markdown' });
            return;
        }

        const parsedCards = cardCodes.map(parseCard);
        const invalidCards = parsedCards.filter(c => c === null);

        if (invalidCards.length > 0) {
            bot.sendMessage(chatId, `‚ùå *Error:* I couldn't understand some of the cards identified. The model might have made a mistake. Please try again.`, { parse_mode: 'Markdown' });
            return;
        }

        const startTime = performance.now();
        const { best } = solveOptimizedV2(parsedCards);
        const endTime = performance.now();
        const solveTime = ((endTime - startTime) / 1000).toFixed(3);

        if (!best) {
            bot.sendMessage(chatId, "Couldn't find a valid arrangement. This is unexpected!");
            return;
        }

        const repeatText = best.isRepeat ? '‚úÖ (Repeat Fantasyland EV)' : '';

        // Apply the new color formatting to all card arrays
        const frontFormatted = best.front.map(formatCardWithColor).join(' ');
        const middleFormatted = best.middle.map(formatCardWithColor).join(' ');
        const backFormatted = best.back.map(formatCardWithColor).join(' ');
        const discardsFormatted = best.discards.map(formatCardWithColor).join(' ');

        const resultMessage = `*Optimal Arrangement Found!*

\`${frontFormatted}\`
\`${middleFormatted}\`
\`${backFormatted}\`

*Discards:* \`${discardsFormatted}\`

*Score:* ${best.finalEV.toFixed(2)} pts ${repeatText}
*Time:* ${solveTime} seconds (solver)
        `;
        bot.sendMessage(chatId, resultMessage, { parse_mode: 'Markdown' });

    } catch (error) {
        console.error("Solver Error:", error);
        bot.sendMessage(chatId, "An unexpected error occurred while solving. Please check the server logs.");
    }
}

// ========== BOT COMMANDS ==========

// --- /start command ---
bot.onText(/\/start/, (msg) => {
    const chatId = msg.chat.id;
    const currentModel = getCurrentModel();
    const startMessage = `Hello! üëã Just send me a screenshot of your cards, and I'll find the optimal arrangement for you.

*Current Vision Model:* ${currentModel.displayName}
*Available Commands:*
/model - Switch vision model
/pro - Gemini 2.5 Pro
/flash - Gemini Flash
/mistrallarge - Mistrall Large
`;
    bot.sendMessage(chatId, startMessage, { parse_mode: 'Markdown' });
});

// --- /solve command (for text input) ---
bot.onText(/\/solve (.+)/, (msg, match) => {
    runSolverAndReply(msg.chat.id, match[1]);
});

// --- /model command (switch models) ---
bot.onText(/\/model/, (msg) => {
    const chatId = msg.chat.id;
    const allModels = getAllModels();
    // const currentModel = getCurrentModel();
    
    const keyboard = {
        inline_keyboard: Object.keys(allModels).map(key => [{
            text: `${allModels[key].displayName} (${allModels[key].provider})${key === currentModelKey ? ' ‚úì' : ''}`,
            callback_data: `model_${key}`
        }])
    };
    
    bot.sendMessage(chatId, '*Select Vision Model:*', { 
        parse_mode: 'Markdown',
        reply_markup: keyboard 
    });
});

// --- /status command ---
bot.onText(/\/status/, (msg) => {
    const chatId = msg.chat.id;
    const currentModel = getCurrentModel();
    
    const statusMessage = `*Current Bot Settings:*

*Vision Model:* ${currentModel.displayName}
*Provider:* ${currentModel.provider}
*Model ID:* \`${currentModel.name}\`

Use /model to switch models.
`;
    bot.sendMessage(chatId, statusMessage, { parse_mode: 'Markdown' });
});

// --- Direct command handlers for Gemini models ---

bot.onText(/\/flash/, (msg) => {
    const chatId = msg.chat.id;
    const success = setCurrentModel('flash');
    
    if (success) {
        const newModel = getCurrentModel();
        bot.sendMessage(chatId, `‚úÖ *Vision model changed to:* ${newModel.displayName}`, { parse_mode: 'Markdown' });
    } else {
        bot.sendMessage(chatId, '‚ùå Error switching model');
    }
});

bot.onText(/\/pro/, (msg) => {
    const chatId = msg.chat.id;
    const success = setCurrentModel('pro');
    
    if (success) {
        const newModel = getCurrentModel();
        bot.sendMessage(chatId, `‚úÖ *Vision model changed to:* ${newModel.displayName}`, { parse_mode: 'Markdown' });
    } else {
        bot.sendMessage(chatId, '‚ùå Error switching model');
    }
});

// --- Direct command handlers for Mistral models ---
bot.onText(/\/mistrallarge/, (msg) => {
    const chatId = msg.chat.id;
    const success = setCurrentModel('mistral-large');
    
    if (success) {
        const newModel = getCurrentModel();
        bot.sendMessage(chatId, `‚úÖ *Vision model changed to:* ${newModel.displayName}`, { parse_mode: 'Markdown' });
    } else {
        bot.sendMessage(chatId, '‚ùå Error switching model');
    }
});
bot.onText(/\/mistralsmall/, (msg) => {
    const chatId = msg.chat.id;
    const success = setCurrentModel('mistral-small');
    
    if (success) {
        const newModel = getCurrentModel();
        bot.sendMessage(chatId, `‚úÖ *Vision model changed to:* ${newModel.displayName}`, { parse_mode: 'Markdown' });
    } else {
        bot.sendMessage(chatId, '‚ùå Error switching model');
    }
});

// --- Handle model selection callbacks ---
bot.on('callback_query', (query) => {
    const chatId = query.message.chat.id;
    const data = query.data;
    
    if (data.startsWith('model_')) {
        const modelKey = data.replace('model_', '');
        const success = setCurrentModel(modelKey);
        
        if (success) {
            const newModel = getCurrentModel();
            bot.answerCallbackQuery(query.id, { text: `Switched to ${newModel.displayName}` });
            bot.editMessageText(`‚úÖ *Vision model changed to:* ${newModel.displayName} (${newModel.provider})`, {
                chat_id: chatId,
                message_id: query.message.message_id,
                parse_mode: 'Markdown'
            });
        } else {
            bot.answerCallbackQuery(query.id, { text: 'Error switching model' });
        }
    }
});

// --- Photo Handler (for image input) ---
bot.on('photo', async (msg) => {
    const chatId = msg.chat.id;

    try {
        // Let the user know the bot is working
        bot.sendChatAction(chatId, 'typing');

        // Get the highest resolution photo
        const photo = msg.photo[msg.photo.length - 1];
        const fileStream = bot.getFileStream(photo.file_id);

        // Download the image into a buffer
        const chunks = [];
        for await (const chunk of fileStream) {
            chunks.push(chunk);
        }
        const imageBuffer = Buffer.concat(chunks);

        // Call the appropriate vision service to identify cards
        const cardStringFromVision = await identifyCardsFromImage(imageBuffer);

        if (!cardStringFromVision) {
            await bot.sendMessage(chatId, "Sorry, I couldn't extract the cards from that image. Please try a clearer screenshot without any obstructions.");
            return;
        }

        // Send the extracted cards immediately
        // await bot.sendMessage(chatId, `üìã *Cards identified:*\n\`/solve ${cardStringFromVision}\``, { parse_mode: 'MarkdownV2' });

        // Run the solver with the identified cards and send the final reply
        await runSolverAndReply(chatId, cardStringFromVision);

    } catch (error) {
        console.error("Photo Handler Error:", error);
        await bot.sendMessage(chatId, "An error occurred while processing your image. Please try again.");
    }
});

console.log('üöÄ FL Solver Bot is running and listening for commands and photos!');

bot.on('polling_error', (error) => {
    console.error('Polling error:', error.code);
});
```

# To do next:

### Better error handling/displaying:

ERROR CATEGORIES:
- Telegram API
- Solver
- Couldn't call the vision API
- Model gave bad response

we can simplify this and have just one generic message in each category:

With te solver function, I never got any errors. If anything goes wrong during the actual solving, we can just send a bot message on telegram saying: "Something went wrong with the solver" (This has never happened. If it happens one day I'll debug from there)
- Same with telegram, never had any issues with the telegram API. No need to change anything related to telegram errors.

The errors i get most are with the vision API calls. Here's the 2 types i get:
- Error calling Gemini API: ApiError: {"error":{"code":503,"message":"The model is overloaded. Please try again later.","status":"UNAVAILABLE"}}

- Error calling Mistral API: SDKError: API error occurred: Status 429
Body: {"object":"error","message":"Service tier capacity exceeded for this model.","type":"service_tier_capacity_exceeded","param":null,"code":"3505"}

- I also get the 'tier capacity exceeded' error with google models sometimes, not sure what the code & details is for those right now...

- And sometimes small models gives bad output.

Here's the appropriate action for each kind of error:

- if Mistral free tier exceeded: Switch model & retry, or quit
- If gemini pro tier exceeded: Switch model & retry, switch API key & retry, or quit (I just a new gemini key, so we can use two. They reset daily so we can alternate if one hits the limit)
- if model bad output: retry, switch model and retry, or quit

We only need one generic message:

"{current model name here}, {error message fetched from the API here or "bad response"} (options as inline buttons for the user to click)" 

Here's all the possible options, we'll show only the appropriate ones based on the particular error:
[retry]
[set gemini pro & retry]
[set gemini flash & retry]
[set mistral large & retry]
[set mistral small & retry]
[swap API key & retry] (I already added the second gemini key to the secrets as 'GEMINI_API_KEY_2')
[quit] (exit without changing anything so the bot is ready for the next screenshot)

Once the user clicks an option, then, do the thing automatically so the user doesnt have to resend the screenshot manually etc...

Im thinking, remove all this duplicate code from the mistral & gemini service files:

```
        // Extract the content from between the triple backticks
        const match = responseText.match(/\`\`\`([\s\S]*?)\`\`\`/);

        if (match && match[1]) {
            // Return the cleaned, trimmed string of cards
            return match[1].trim();
        } else {
            console.error("Mistral response did not contain the expected format:", responseText);
            return null;
        }

    } catch (error) {
        console.error("Error calling Mistral API:", error);
        throw new Error("Failed to get a valid response from the vision model.");
    }
```

Handle the response extraction once in the photo handler along with all possible errors:
```
// --- Photo Handler (for image input) ---
bot.on('photo', async (msg) => {
    const chatId = msg.chat.id;

    try {
        // Let the user know the bot is working
        bot.sendChatAction(chatId, 'typing');

        // Get the highest resolution photo
        const photo = msg.photo[msg.photo.length - 1];
        const fileStream = bot.getFileStream(photo.file_id);

        // Download the image into a buffer
        const chunks = [];
        for await (const chunk of fileStream) {
            chunks.push(chunk);
        }
        const imageBuffer = Buffer.concat(chunks);

        // Call the appropriate vision service to identify cards
        const cardStringFromVision = await identifyCardsFromImage(imageBuffer);

//// HANDLE ERROR IF CAN'T CALL THE VISION API
//// ELSE
//// EXTRACT RESPONSE FROM THE TRIPLE BACKTICKS
//// HANDLE ERROR IF BAD RESPONSE
//// ELSE
//// Run the solver with the identified cards and send the final reply
//// HANDLE ERROR SOLVER FAILS
//// ELSE
//// FORMAT SOLUTION NICELY
//// AND SEND IT AS THE BOT REPLY

});
```

Something like that...?